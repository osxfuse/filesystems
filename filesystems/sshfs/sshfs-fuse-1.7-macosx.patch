diff -Naur old/Makefile.in new/Makefile.in
--- old/Makefile.in	2006-08-17 03:07:05.000000000 -0700
+++ new/Makefile.in	2007-04-19 03:54:33.000000000 -0700
@@ -597,8 +597,13 @@
 uninstall-local:
 	rm -f "$(DESTDIR)$(libdir)/sshnodelay.so"
 
+ifeq "$(shell uname)" "Darwin"
+sshnodelay.so:
+	$(CC) -Wall -dynamiclib $(CFLAGS) $(sshnodelay_libs) -install_name "$(DESTDIR)$(libdir)/sshnodelay.so" sshnodelay.c -o sshnodelay.so
+else
 sshnodelay.so:
 	$(CC) -Wall -W -s --shared -fPIC $(sshnodelay_libs) sshnodelay.c -o sshnodelay.so
+endif
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -Naur old/README.MacFUSE new/README.MacFUSE
--- old/README.MacFUSE	1969-12-31 16:00:00.000000000 -0800
+++ new/README.MacFUSE	2007-04-19 03:54:33.000000000 -0700
@@ -0,0 +1,7 @@
+MacFUSE Project Page:
+
+http://code.google.com/p/macfuse/
+
+Making a Universal build of sshfs:
+
+CFLAGS="-D__FreeBSD__=10 -DSSH_NODELAY_WORKAROUND -O -g -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.4u.sdk" LDFLAGS="-arch i386 -arch ppc" ./configure --prefix=/usr/local --disable-dependency-tracking
diff -Naur old/cache.c new/cache.c
--- old/cache.c	2006-08-16 01:51:21.000000000 -0700
+++ new/cache.c	2007-04-19 03:54:33.000000000 -0700
@@ -116,9 +116,20 @@
     pthread_mutex_unlock(&cache.lock);
 }
 
+static int cache_del_children(const char *key, void *val_, const char *path)
+{
+    (void) val_;
+    if (strncmp(key, path, strlen(path)) == 0)
+        return TRUE;
+    else
+        return FALSE;
+}
+
 static void cache_do_rename(const char *from, const char *to)
 {
     pthread_mutex_lock(&cache.lock);
+    g_hash_table_foreach_remove(cache.table, (GHRFunc) cache_del_children,
+                                (char *) from);
     cache_purge(from);
     cache_purge(to);
     cache_purge_parent(from);
@@ -250,12 +261,14 @@
                          const struct stat *stbuf)
 {
     int err = ch->filler(ch->h, name, 0, 0);
-    if (!err && (stbuf->st_mode & S_IFMT)) {
-        char *fullpath;
+    if (!err) {
         g_ptr_array_add(ch->dir, g_strdup(name));
-        fullpath = g_strdup_printf("%s/%s", !ch->path[1] ? "" : ch->path, name);
-        cache_add_attr(fullpath, stbuf);
-        g_free(fullpath);
+        if (stbuf->st_mode & S_IFMT) {
+            char *fullpath =
+                g_strdup_printf("%s/%s", !ch->path[1] ? "" : ch->path, name);
+            cache_add_attr(fullpath, stbuf);
+            g_free(fullpath);
+        }
     }
     return err;
 }
diff -Naur old/sshfs.c new/sshfs.c
--- old/sshfs.c	2006-08-18 03:34:08.000000000 -0700
+++ new/sshfs.c	2007-04-19 04:10:38.000000000 -0700
@@ -18,7 +18,9 @@
 #include <string.h>
 #include <stdint.h>
 #include <errno.h>
+#if !(__FreeBSD__ >= 10)
 #include <semaphore.h>
+#endif
 #include <pthread.h>
 #include <netdb.h>
 #include <signal.h>
@@ -30,6 +32,9 @@
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <glib.h>
+#if (__FreeBSD__ >= 10)
+#include <libgen.h>
+#endif
 
 #include "cache.h"
 
@@ -100,6 +105,32 @@
 
 #define SSHNODELAY_SO "sshnodelay.so"
 
+#if (__FreeBSD__ >= 10)
+#undef sem_t
+
+#undef sem_init
+#undef sem_destroy
+#undef sem_post
+#undef sem_wait
+
+#include <mach/mach.h>
+
+typedef semaphore_t sem_t;
+
+#define sem_init(s, a, b) \
+    semaphore_create(mach_task_self(), (s), SYNC_POLICY_FIFO, 0)
+#define sem_destroy(s) semaphore_destroy(mach_task_self(), (semaphore_t)*(s))
+#define sem_post(s)    semaphore_signal((semaphore_t)*(s))
+#define sem_wait(s)    semaphore_wait((semaphore_t)*(s))
+
+#ifndef LIBDIR
+#define LIBDIR "/usr/local/lib"
+#endif
+
+static char sshfs_program_path[PATH_MAX] = { 0 };
+
+#endif
+
 struct buffer {
     uint8_t *p;
     size_t len;
@@ -124,6 +155,7 @@
     struct timeval start;
     void *data;
     request_func end_func;
+    size_t len;
     struct list_head list;
 };
 
@@ -147,6 +179,7 @@
     int is_seq;
     int connver;
     int modifver;
+    int refs;
 };
 
 struct sshfs {
@@ -157,7 +190,9 @@
     char *workarounds;
     int rename_workaround;
     int nodelay_workaround;
+    int nodelaysrv_workaround;
     int truncate_workaround;
+    int buflimit_workaround;
     int transform_symlinks;
     int follow_symlinks;
     int no_check_root;
@@ -184,6 +219,9 @@
     unsigned blksize;
     char *progname;
     long modifver;
+    unsigned outstanding_len;
+    unsigned max_outstanding_len;
+    pthread_cond_t outstanding_cond;
 };
 
 static struct sshfs sshfs;
@@ -270,16 +308,24 @@
 static struct fuse_opt workaround_opts[] = {
     SSHFS_OPT("none",       rename_workaround, 0),
     SSHFS_OPT("none",       nodelay_workaround, 0),
+    SSHFS_OPT("none",       nodelaysrv_workaround, 0),
     SSHFS_OPT("none",       truncate_workaround, 0),
+    SSHFS_OPT("none",       buflimit_workaround, 0),
     SSHFS_OPT("all",        rename_workaround, 1),
     SSHFS_OPT("all",        nodelay_workaround, 1),
+    SSHFS_OPT("all",        nodelaysrv_workaround, 1),
     SSHFS_OPT("all",        truncate_workaround, 1),
+    SSHFS_OPT("all",        buflimit_workaround, 1),
     SSHFS_OPT("rename",     rename_workaround, 1),
     SSHFS_OPT("norename",   rename_workaround, 0),
     SSHFS_OPT("nodelay",    nodelay_workaround, 1),
     SSHFS_OPT("nonodelay",  nodelay_workaround, 0),
+    SSHFS_OPT("nodelaysrv", nodelaysrv_workaround, 1),
+    SSHFS_OPT("nonodelaysrv", nodelaysrv_workaround, 0),
     SSHFS_OPT("truncate",   truncate_workaround, 1),
     SSHFS_OPT("notruncate", truncate_workaround, 0),
+    SSHFS_OPT("buflimit",   buflimit_workaround, 1),
+    SSHFS_OPT("nobuflimit", buflimit_workaround, 0),
     FUSE_OPT_END
 };
 
@@ -627,13 +673,36 @@
         _exit(1);
 }
 
+#ifdef SSH_NODELAY_WORKAROUND
 static int do_ssh_nodelay_workaround(void)
 {
+#if (__FreeBSD__ >= 10)
+    char *oldpreload = getenv("DYLD_INSERT_LIBRARIES");
+#else
     char *oldpreload = getenv("LD_PRELOAD");
+#endif
     char *newpreload;
     char sopath[PATH_MAX];
     int res;
 
+#if (__FreeBSD__ >= 10)
+    char *sshfs_program_path_base = NULL;
+    if (!sshfs_program_path[0]) {
+        goto nobundle;
+    }
+    sshfs_program_path_base = basename(sshfs_program_path); 
+    if (!sshfs_program_path_base) {
+        goto nobundle;
+    }
+    snprintf(sopath, sizeof(sopath), "%s/%s", sshfs_program_path_base,
+             SSHNODELAY_SO); 
+    res = access(sopath, R_OK);
+    if (res == -1) {
+        goto nobundle;
+    }
+    goto pathok;
+nobundle:
+#endif
     snprintf(sopath, sizeof(sopath), "%s/%s", LIBDIR, SSHNODELAY_SO);
     res = access(sopath, R_OK);
     if (res == -1) {
@@ -657,17 +726,26 @@
             return -1;
         }
     }
+#if (__FreeBSD__ >= 10)
+pathok:
+#endif
 
     newpreload = g_strdup_printf("%s%s%s",
                                  oldpreload ? oldpreload : "",
                                  oldpreload ? " " : "",
                                  sopath);
 
+#if (__FreeBSD__ >= 10)
+    if (!newpreload || setenv("DYLD_INSERT_LIBRARIES", newpreload, 1) == -1)
+        fprintf(stderr, "warning: failed set DYLD_INSERT_LIBRARIES for ssh nodelay workaround\n");
+#else
     if (!newpreload || setenv("LD_PRELOAD", newpreload, 1) == -1)
         fprintf(stderr, "warning: failed set LD_PRELOAD for ssh nodelay workaround\n");
+#endif
     g_free(newpreload);
     return 0;
 }
+#endif
 
 static int start_ssh(void)
 {
@@ -687,8 +765,15 @@
     } else if (pid == 0) {
         int devnull;
 
+#ifdef SSH_NODELAY_WORKAROUND
         if (sshfs.nodelay_workaround && do_ssh_nodelay_workaround() == -1)
             fprintf(stderr, "warning: ssh nodelay workaround disabled\n");
+#endif
+
+        if (sshfs.nodelaysrv_workaround) {
+            /* Hack to work around missing TCP_NODELAY setting in sshd  */
+            sshfs.ssh_args.argv[1] = "-X";
+        }
 
         devnull = open("/dev/null", O_WRONLY);
 
@@ -822,7 +907,7 @@
     unsigned nout = 0;
 
     assert(count <= SFTP_MAX_IOV - 1);
-    buf_init(&buf, 5);
+    buf_init(&buf, 9);
     buf_add_uint32(&buf, iov_length(iov, count) + 5);
     buf_add_uint8(&buf, type);
     buf_add_uint32(&buf, id);
@@ -947,8 +1032,13 @@
                                                      GUINT_TO_POINTER(id));
         if (req == NULL)
             fprintf(stderr, "request %i not found\n", id);
-        else
+        else {
+            int was_over = sshfs.outstanding_len > sshfs.max_outstanding_len;
+            sshfs.outstanding_len -= req->len;
+            if (was_over && sshfs.outstanding_len <= sshfs.max_outstanding_len)
+                pthread_cond_broadcast(&sshfs.outstanding_cond);
             g_hash_table_remove(sshfs.reqtab, GUINT_TO_POINTER(id));
+        }
         pthread_mutex_unlock(&sshfs.lock);
         if (req != NULL) {
             struct timeval now;
@@ -1046,7 +1136,7 @@
 static int sftp_init()
 {
     int res = -1;
-    uint32_t version;
+    uint32_t version = 0;
     struct buffer buf;
     buf_init(&buf, 0);
     if (sftp_send_iov(SSH_FXP_INIT, PROTO_VERSION, NULL, 0) == -1)
@@ -1342,6 +1432,11 @@
         pthread_mutex_unlock(&sshfs.lock);
         goto out;
     }
+    req->len = iov_length(iov, count) + 9;
+    sshfs.outstanding_len += req->len;
+    while (sshfs.outstanding_len > sshfs.max_outstanding_len)
+        pthread_cond_wait(&sshfs.outstanding_cond, &sshfs.lock);
+
     g_hash_table_insert(sshfs.reqtab, GUINT_TO_POINTER(id), req);
     gettimeofday(&req->start, NULL);
     DEBUG("[%05i] %s\n", id, type_name(type));
@@ -1768,6 +1863,7 @@
     pthread_cond_init(&sf->write_finished, NULL);
     /* Assume random read after open */
     sf->is_seq = 0;
+    sf->refs = 1;
     sf->next_pos = 0;
     sf->modifver= sshfs.modifver;
     sf->connver = sshfs.connver;
@@ -1851,6 +1947,19 @@
     return sshfs_flush(path, fi);
 }
 
+static void sshfs_file_put(struct sshfs_file *sf)
+{
+    sf->refs--;
+    if (!sf->refs)
+        g_free(sf);
+}
+
+static struct sshfs_file *sshfs_file_get(struct sshfs_file *sf)
+{
+    sf->refs++;
+    return sf;
+}
+
 static int sshfs_release(const char *path, struct fuse_file_info *fi)
 {
     struct sshfs_file *sf = get_sshfs_file(fi);
@@ -1861,7 +1970,7 @@
     }
     buf_free(handle);
     chunk_put_locked(sf->readahead);
-    g_free(sf);
+    sshfs_file_put(sf);
     return 0;
 }
 
@@ -2084,6 +2193,7 @@
     }
     list_del(&req->list);
     pthread_cond_broadcast(&sf->write_finished);
+    sshfs_file_put(sf);
 }
 
 static int sshfs_write(const char *path, const char *wbuf, size_t size,
@@ -2110,7 +2220,7 @@
     iov[1].iov_len = size;
     if (!sshfs.sync_write && !sf->write_error)
         err = sftp_request_send(SSH_FXP_WRITE, iov, 2, sshfs_write_begin,
-                                 sshfs_write_end, 0, sf, NULL);
+                                 sshfs_write_end, 0, sshfs_file_get(sf), NULL);
     else
         err = sftp_request_iov(SSH_FXP_WRITE, iov, 2, SSH_FXP_STATUS, NULL);
     buf_free(&buf);
@@ -2330,6 +2440,7 @@
 {
     pthread_mutex_init(&sshfs.lock, NULL);
     pthread_mutex_init(&sshfs.lock_write, NULL);
+    pthread_cond_init(&sshfs.outstanding_cond, NULL);
     sshfs.reqtab = g_hash_table_new(NULL, NULL);
     if (!sshfs.reqtab) {
         fprintf(stderr, "failed to create hash table\n");
@@ -2396,8 +2507,12 @@
 "             none             no workarounds enabled\n"
 "             all              all workarounds enabled\n"
 "             [no]rename       fix renaming to existing file (default: off)\n"
+#ifdef SSH_NODELAY_WORKAROUND
 "             [no]nodelay      set nodelay tcp flag in ssh (default: on)\n"
+#endif
+"             [no]nodelaysrv   set nodelay tcp flag in sshd (default: on)\n"
 "             [no]truncate     fix truncate for old servers (default: off)\n"
+"             [no]buflimit     fix buffer fillup bug in server (default: on)\n"
 "    -o idmap=TYPE          user/group ID mapping, possible types are:\n"
 "             none             no translation of the ID space (default)\n"
 "             user             only translate UID of connecting user\n"
@@ -2476,7 +2591,12 @@
         exit(1);
 
     case KEY_VERSION:
+#if (__FreeBSD__ >= 10)
+        fprintf(stderr, "SSHFS version %s (MacFUSE, %d, %s, %s)\n",
+                PACKAGE_VERSION, 7, __DATE__, __TIME__);
+#else
         fprintf(stderr, "SSHFS version %s\n", PACKAGE_VERSION);
+#endif
 #if FUSE_VERSION >= 25
         fuse_opt_add_arg(outargs, "--version");
         sshfs_fuse_main(outargs);
@@ -2542,8 +2662,17 @@
         fuse_opt_insert_arg(args, 1, "-olarge_read");
 }
 
+#if (__FreeBSD__ >= 10)
+int main(int argc, char *argv[], __unused char *envp[], char **exec_path)
+#else
 int main(int argc, char *argv[])
+#endif
 {
+#if (__FreeBSD__ >= 10)
+    if (!realpath(*exec_path, sshfs_program_path)) {
+        memset(sshfs_program_path, 0, PATH_MAX);
+    }
+#endif
     int res;
     struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
     char *tmp;
@@ -2554,8 +2683,14 @@
     sshfs.blksize = 4096;
     sshfs.max_read = 65536;
     sshfs.nodelay_workaround = 1;
+    sshfs.nodelaysrv_workaround = 0;
+#if (__FreeBSD__ >= 10)
+    sshfs.rename_workaround = 1;
+#else
     sshfs.rename_workaround = 0;
+#endif
     sshfs.truncate_workaround = 0;
+    sshfs.buflimit_workaround = 1;
     sshfs.ssh_ver = 2;
     sshfs.progname = argv[0];
     ssh_add_arg("ssh");
@@ -2567,6 +2702,14 @@
         parse_workarounds() == -1)
         exit(1);
 
+    if (sshfs.buflimit_workaround)
+        /* Work around buggy sftp-server in OpenSSH.  Without this on
+           a slow server a 10Mbyte buffer would fill up and the server
+           would abort */
+        sshfs.max_outstanding_len = 8388608;
+    else
+        sshfs.max_outstanding_len = ~0;
+
     if (!sshfs.host) {
         fprintf(stderr, "missing host\n");
         fprintf(stderr, "see `%s -h' for usage\n", argv[0]);
diff -Naur old/sshnodelay.c new/sshnodelay.c
--- old/sshnodelay.c	2006-02-01 01:43:22.000000000 -0800
+++ new/sshnodelay.c	2007-04-19 03:54:33.000000000 -0700
@@ -5,6 +5,31 @@
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 
+#if (__FreeBSD__ >= 10)
+
+int custom_connect(int sock, const struct sockaddr *addr, socklen_t addrlen);
+
+typedef struct interpose_s {
+    void *new_func;
+    void *orig_func;
+} interpose_t;
+
+static const interpose_t interposers[] \
+    __attribute__ ((section("__DATA, __interpose"))) = {
+        { (void *)custom_connect,  (void *)connect  },
+    };
+   
+int custom_connect(int sock, const struct sockaddr *addr, socklen_t addrlen)
+{
+    int res = connect(sock, addr, addrlen);
+    if (!res && addr->sa_family == AF_INET) {
+        int opt = 1;
+        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+    }
+    return res;
+}
+
+#else
 int connect(int sock, const struct sockaddr *addr, socklen_t addrlen)
 {
     int (*next_connect)(int, const struct sockaddr *, socklen_t) =
@@ -14,5 +39,5 @@
         int opt = 1;
         setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
     }
-    return res;
 }
+#endif
